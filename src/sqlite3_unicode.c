#include "simstr/simple_unicode.h"
/*************************************************************************************************
** The author disclaims copyright to this source code.  In place of a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
**************************************************************************************************
**
** This file implements true UNICODE functionality for SQLite in regards of case-insensitive comparison
** of unicode data and SQLite. It uses UNICODE mapping tables to provide the following to SQLite:
**
**   * An implementation of SQL scalar upper(), lower(), title(), fold() functions to normalize strings 
**     for comparison by case folding.
**
**   * An implementation of SQL scalar unaccent() function to normalize strings for comparison by removing accents.
**
**   * An implementation of the LIKE operator that uses casefolding to provide case-independent matching.
**
** Compile the project with the following preprocessor definitions in order to enable the code below.
**   * SQLITE_ENABLE_UNICODE and SQLITE_CORE for static  library, (building sqlite3.a  | lib)
**   * SQLITE_ENABLE_UNICODE                 for dynamic library, (building sqlite3.so | dll)
**
** 
** The following function needs to be called at program startup to initialise unicode functionality
**   * sqlite3_unicode_load();
**
** The following function needs to be called before program exit to correctly uninitialise unicode functionality
**   * sqlite3_unicode_free();
*/
#ifdef _MSC_VER
#pragma warning(disable:4305 13 90)
#endif

/*
** Un|Comment to provide additional unicode support to SQLite3 or adjust size for unused features
*/
#define SQLITE3_UNICODE_FOLD      // ~ 10KB increase
#define SQLITE3_UNICODE_LOWER     // ~ 10KB increase
#define SQLITE3_UNICODE_UPPER     // ~ 10KB increase
#define SQLITE3_UNICODE_TITLE     // ~ 10KB increase
#define SQLITE3_UNICODE_UNACC     // ~ 30KB increase
                                  // _______________
                                  // ~ 70KB increase

/*
** SQLITE3_UNICODE_COLLATE will register and use the custom nocase collation instead of the standard
** one, which supports case folding and unaccenting.
*/
#define SQLITE3_UNICODE_COLLATE   // requires SQLITE3_UNICODE_FOLD to be defined as well.

/*
** SQLITE3_UNICODE_UNACC_AUTOMATIC will automatically try to unaccent any characters that
** are over the 0x80 character in the LIKE comparison operation and in the NOCASE collation sequence.
*/
#define SQLITE3_UNICODE_UNACC_AUTOMATIC    // requires SQLITE3_UNICODE_UNACC to be defined as well.

/*************************************************************************************************
** DO NOT MODIFY BELOW THIS LINE
**************************************************************************************************/

/* Generated by builder. Do not modify. Start unicode_version_defines */
/*
File was generated by : sqlite3_unicode.in
File was generated on : Fri Jun  5 01:10:23 2009
Using unicode data db : UnicodeData.txt
Using unicode fold db : CaseFolding.txt
*/
#define SQLITE3_UNICODE_VERSION_MAJOR        5
#define SQLITE3_UNICODE_VERSION_MINOR        1
#define SQLITE3_UNICODE_VERSION_MICRO        0
#define SQLITE3_UNICODE_VERSION_BUILD        12

#define __SQLITE3_UNICODE_VERSION_STRING(a,b,c,d) #a "." #b "." #c "." #d
#define _SQLITE3_UNICODE_VERSION_STRING(a,b,c,d)  __SQLITE3_UNICODE_VERSION_STRING(a,b,c,d)
#define SQLITE3_UNICODE_VERSION_STRING            _SQLITE3_UNICODE_VERSION_STRING(SQLITE3_UNICODE_VERSION_MAJOR,SQLITE3_UNICODE_VERSION_MINOR,SQLITE3_UNICODE_VERSION_MICRO,SQLITE3_UNICODE_VERSION_BUILD)

/* Generated by builder. Do not modify. End unicode_version_defines */

#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_UNICODE)

#ifndef SQLITE_CORE
#include <sqlite3ext.h>
SQLITE_EXTENSION_INIT1
#else
#include <sqlite3.h>
#endif

#include <assert.h>
#include <string.h>

#ifndef _SQLITE3_UNICODE_H
#define _SQLITE3_UNICODE_H

#ifdef __cplusplus
extern "C" {
#endif

/*
** Add the ability to override 'extern'
*/
/*
** <sqlite3_unicode>
** The define of SQLITE_EXPORT is necessary to add the ability of exporting
** functions for both Microsoft Windows and Linux systems without the need
** of a .def file containing the names of the functions being exported.
*/
#ifndef SQLITE_EXPORT
# if ((defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)) && (!defined(SQLITE_CORE)))
#  define SQLITE_EXPORT __declspec(dllexport)
# else
#  define SQLITE_EXPORT SQLITE_EXTERN
# endif
#endif

#ifndef SQLITE_PRIVATE
# define SQLITE_PRIVATE static
#endif
#ifndef SQLITE_API
# define SQLITE_API
#endif

/*
** Integers of known sizes.  These typedefs might change for architectures
** where the sizes very.  Preprocessor macros are available so that the
** types can be conveniently redefined at compile-type.  Like this:
**
**         cc '-DUINTPTR_TYPE=long long int' ...
*/
#ifndef UINT32_TYPE
# ifdef HAVE_UINT32_T
#  define UINT32_TYPE uint32_t
# else
#  define UINT32_TYPE unsigned int
# endif
#endif
#ifndef UINT16_TYPE
# ifdef HAVE_UINT16_T
#  define UINT16_TYPE uint16_t
# else
#  define UINT16_TYPE unsigned short int
# endif
#endif
#ifndef INT16_TYPE
# ifdef HAVE_INT16_T
#  define INT16_TYPE int16_t
# else
#  define INT16_TYPE short int
# endif
#endif
#ifndef UINT8_TYPE
# ifdef HAVE_UINT8_T
#  define UINT8_TYPE uint8_t
# else
#  define UINT8_TYPE unsigned char
# endif
#endif
#ifndef INT8_TYPE
# ifdef HAVE_INT8_T
#  define INT8_TYPE int8_t
# else
#  define INT8_TYPE signed char
# endif
#endif
#ifndef LONGDOUBLE_TYPE
# define LONGDOUBLE_TYPE long double
#endif
typedef sqlite_int64 i64;          /* 8-byte signed integer */
typedef sqlite_uint64 u64;         /* 8-byte unsigned integer */
typedef UINT32_TYPE u32;           /* 4-byte unsigned integer */
typedef UINT16_TYPE u16;           /* 2-byte unsigned integer */
typedef INT16_TYPE i16;            /* 2-byte signed integer */
typedef UINT8_TYPE u8;             /* 1-byte unsigned integer */
typedef INT8_TYPE i8;              /* 1-byte signed integer */

/*
** Another built-in collating sequence: NOCASE. 
**
** This collating sequence is intended to be used for "case independant
** comparison". SQLite's knowledge of upper and lower case equivalents
** extends only to the 26 characters used in the English language.
**
** At the moment there is only a UTF-8 implementation.
*/
/*
** <sqlite3_unicode>
** The built-in collating sequence: NOCASE is extended to accomodate the
** unicode case folding mapping tables to normalize characters to their
** fold equivalents and test them for equality.
**
** Both UTF-8 and UTF-16 implementations are supported.
** 
** (void *)encoding takes the following values
**   * SQLITE_UTF8  for UTF-8  encoded string comparison
**   * SQLITE_UFT16 for UTF-16 encoded string comparison
*/
SQLITE_EXPORT int sqlite3_unicode_collate(
  void *encoding,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
  );

/*
** <sqlite3_unicode>
** Register the UNICODE extension functions with database db.
*/
SQLITE_EXPORT int sqlite3_unicode_init(sqlite3 *db);

/*
** <sqlite3_unicode>
** The following function needs to be called at application startup to load the extension.
*/
SQLITE_EXPORT int sqlite3_unicode_load();

/*
** <sqlite3_unicode>
** The following function needs to be called before application exit to unload the extension.
*/
SQLITE_EXPORT void sqlite3_unicode_free();

#ifdef __cplusplus
}
#endif

#endif /* _SQLITE3_UNICODE_H */

/*
** Check to see if this machine uses EBCDIC.  (Yes, believe it or
** not, there are still machines out there that use EBCDIC.)
*/
#if 'A' == '\301'
# define SQLITE_EBCDIC 1
#else
# define SQLITE_ASCII 1
#endif

/*
** Assuming zIn points to the first byte of a UTF-8 character,
** advance zIn to point to the first byte of the next UTF-8 character.
*/
#define SQLITE_SKIP_UTF8(zIn) {                        \
  if( (*(zIn++))>=0xc0 ){                              \
    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \
  }                                                    \
}

/*
** pZ is a UTF-8 encoded unicode string. If nByte is less than zero,
** return the number of unicode characters in pZ up to (but not including)
** the first 0x00 byte. If nByte is not less than zero, return the
** number of unicode characters in the first nByte of pZ (or up to 
** the first 0x00, whichever comes first).
*/
SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *zIn, int nByte){
  int r = 0;
  const u8 *z = (const u8*)zIn;
  const u8 *zTerm;
  if( nByte>=0 ){
    zTerm = &z[nByte];
  }else{
    zTerm = (const u8*)(-1);
  }
  assert( z<=zTerm );
  while( *z!=0 && z<zTerm ){
    SQLITE_SKIP_UTF8(z);
    r++;
  }
  return r;
}

/*
** This lookup table is used to help decode the first byte of
** a multi-byte UTF8 character.
*/
static const unsigned char sqlite3Utf8Trans1[] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};

/*
** Translate a single UTF-8 character.  Return the unicode value.
**
** During translation, assume that the byte that zTerm points
** is a 0x00.
**
** Write a pointer to the next unread byte back into *pzNext.
**
** Notes On Invalid UTF-8:
**
**  *  This routine never allows a 7-bit character (0x00 through 0x7f) to
**     be encoded as a multi-byte character.  Any multi-byte character that
**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.
**
**  *  This routine never allows a UTF16 surrogate value to be encoded.
**     If a multi-byte character attempts to encode a value between
**     0xd800 and 0xe000 then it is rendered as 0xfffd.
**
**  *  Bytes in the range of 0x80 through 0xbf which occur as the first
**     byte of a character are interpreted as single-byte characters
**     and rendered as themselves even though they are technically
**     invalid characters.
**
**  *  This routine accepts an infinite number of different UTF8 encodings
**     for unicode values 0x80 and greater.  It do not change over-length
**     encodings to 0xfffd as some systems recommend.
*/
#define READ_UTF8(zIn, zTerm, c)                           \
  c = *(zIn++);                                            \
  if( c>=0xc0 ){                                           \
    c = sqlite3Utf8Trans1[c-0xc0];                         \
    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
      c = (c<<6) + (0x3f & *(zIn++));                      \
    }                                                      \
    if( c<0x80                                             \
        || (c&0xFFFFF800)==0xD800                          \
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
  }
SQLITE_PRIVATE int sqlite3Utf8Read(
                                   const unsigned char *z,         /* First byte of UTF-8 character */
                                   const unsigned char *zTerm,     /* Pretend this byte is 0x00 */
                                   const unsigned char **pzNext    /* Write first byte past UTF-8 char here */
                                   ){
                                     int c;
                                     READ_UTF8(z, zTerm, c);
                                     *pzNext = z;
                                     return c;
}

/* An array to map all upper-case characters into their corresponding
** lower-case character. 
**
** SQLite only considers US-ASCII (or EBCDIC) characters.  We do not
** handle case conversions for the UTF character set since the tables
** involved are nearly as big or bigger than SQLite itself.
*/
#ifndef SQLITE3_UNICODE_FOLD
SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {
#ifdef SQLITE_ASCII
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,
    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,
    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,
    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,
    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,
    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,
    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,
    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,
    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,
    252,253,254,255
#endif
#ifdef SQLITE_EBCDIC
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /* 0x */
     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /* 1x */
     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, /* 2x */
     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /* 3x */
     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /* 4x */
     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /* 5x */
     96, 97, 66, 67, 68, 69, 70, 71, 72, 73,106,107,108,109,110,111, /* 6x */
    112, 81, 82, 83, 84, 85, 86, 87, 88, 89,122,123,124,125,126,127, /* 7x */
    128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /* 8x */
    144,145,146,147,148,149,150,151,152,153,154,155,156,157,156,159, /* 9x */
    160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /* Ax */
    176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /* Bx */
    192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /* Cx */
    208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /* Dx */
    224,225,162,163,164,165,166,167,168,169,232,203,204,205,206,207, /* Ex */
    239,240,241,242,243,244,245,246,247,248,249,219,220,221,222,255, /* Fx */
#endif
};
#endif

/*
** For LIKE and GLOB matching on EBCDIC machines, assume that every
** character is exactly one byte in size.  Also, all characters are
** able to participate in upper-case-to-lower-case mappings in EBCDIC
** whereas only characters less than 0x80 do in ASCII.
*/
/*
** <sqlite3_unicode>
** The buit-in function has been extended to accomodate UTF-8 and UTF-16
** unicode strings containing characters over the 0x80 character limit as
** per the ASCII encoding imposed by SQlite.
**
** The functions below will use the sqlite3_unicode_fold() when 
** SQLITE3_UNICODE_FOLD is defined and additonally sqlite_unicode_unacc()
** when SQLITE3_UNICODE_UNACC_AUTOMATIC is defined to normilize
** UTF-8 and UTF-16 encoded strings.
*/
#if defined(SQLITE_EBCDIC)
# define sqlite3Utf8Read(A,B,C)  (*(A++))
# define GlogUpperToLower(A)     A = sqlite3UpperToLower[A]
#else
# if defined(SQLITE3_UNICODE_UNACC) && defined(SQLITE3_UNICODE_UNACC_AUTOMATIC) && defined(SQLITE3_UNICODE_FOLD)
#define GlogUpperToLower(A) A = simpleUnicodeFold(simpleUnicodeUnacc(A, 0, 0))
# elif defined(SQLITE3_UNICODE_FOLD)
#define GlogUpperToLower(A) A = simpleUnicodeFold(A)
# else
#  define GlogUpperToLower(A)    if( A<0x80 ){ A = sqlite3UpperToLower[A]; }
# endif
#endif

/*
** Maximum length (in bytes) of the pattern in a LIKE or GLOB
** operator.
*/
#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH
# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000
#endif

/*
** A structure defining how to do GLOB-style comparisons.
*/
struct compareInfo {
  u8 matchAll;
  u8 matchOne;
  u8 matchSet;
  u8 noCase;
};

/* The correct SQL-92 behavior is for the LIKE operator to ignore
** case.  Thus  'a' LIKE 'A' would be true. */
static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };

/*
** Compare two UTF-8 strings for equality where the first string can
** potentially be a "glob" expression.  Return true (1) if they
** are the same and false (0) if they are different.
**
** Globbing rules:
**
**      '*'       Matches any sequence of zero or more characters.
**
**      '?'       Matches exactly one character.
**
**     [...]      Matches one character from the enclosed list of
**                characters.
**
**     [^...]     Matches one character not in the enclosed list.
**
** With the [...] and [^...] matching, a ']' character can be included
** in the list by making it the first character after '[' or '^'.  A
** range of characters can be specified using '-'.  Example:
** "[a-z]" matches any single lower-case letter.  To match a '-', make
** it the last character in the list.
**
** This routine is usually quick, but can be N**2 in the worst case.
**
** Hints: to match '*' or '?', put them in "[]".  Like this:
**
**         abc[*]xyz        Matches "abc*xyz" only
*/
static int patternCompare(
  const u8 *zPattern,              /* The glob pattern */
  const u8 *zString,               /* The string to compare against the glob */
  const struct compareInfo *pInfo, /* Information about how to do the compare */
  const int esc                    /* The escape character */
){
  int c, c2;
  int invert;
  int seen;
  u8 matchOne = pInfo->matchOne;
  u8 matchAll = pInfo->matchAll;
  u8 matchSet = pInfo->matchSet;
  u8 noCase = pInfo->noCase; 
  int prevEscape = 0;     /* True if the previous character was 'escape' */

  while( (c = sqlite3Utf8Read(zPattern,0,&zPattern))!=0 ){
    if( !prevEscape && c==matchAll ){
      while( (c=sqlite3Utf8Read(zPattern,0,&zPattern)) == matchAll
               || c == matchOne ){
        if( c==matchOne && sqlite3Utf8Read(zString, 0, &zString)==0 ){
          return 0;
        }
      }
      if( c==0 ){
        return 1;
      }else if( c==esc ){
        c = sqlite3Utf8Read(zPattern, 0, &zPattern);
        if( c==0 ){
          return 0;
        }
      }else if( c==matchSet ){
        assert( esc==0 );         /* This is GLOB, not LIKE */
        assert( matchSet<0x80 );  /* '[' is a single-byte character */
        while( *zString && patternCompare(&zPattern[-1],zString,pInfo,esc)==0 ){
          SQLITE_SKIP_UTF8(zString);
        }
        return *zString!=0;
      }
      while( (c2 = sqlite3Utf8Read(zString,0,&zString))!=0 ){
        if( noCase ){
          GlogUpperToLower(c2);
          GlogUpperToLower(c);
          while( c2 != 0 && c2 != c ){
            c2 = sqlite3Utf8Read(zString, 0, &zString);
            GlogUpperToLower(c2);
          }
        }else{
          while( c2 != 0 && c2 != c ){
            c2 = sqlite3Utf8Read(zString, 0, &zString);
          }
        }
        if( c2==0 ) return 0;
        if( patternCompare(zPattern,zString,pInfo,esc) ) return 1;
      }
      return 0;
    }else if( !prevEscape && c==matchOne ){
      if( sqlite3Utf8Read(zString, 0, &zString)==0 ){
        return 0;
      }
    }else if( c==matchSet ){
      int prior_c = 0;
      assert( esc==0 );    /* This only occurs for GLOB, not LIKE */
      seen = 0;
      invert = 0;
      c = sqlite3Utf8Read(zString, 0, &zString);
      if( c==0 ) return 0;
      c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);
      if( c2=='^' ){
        invert = 1;
        c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);
      }
      if( c2==']' ){
        if( c==']' ) seen = 1;
        c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);
      }
      while( c2 && c2!=']' ){
        if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){
          c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);
          if( c>=prior_c && c<=c2 ) seen = 1;
          prior_c = 0;
        }else{
          if( c==c2 ){
            seen = 1;
          }
          prior_c = c2;
        }
        c2 = sqlite3Utf8Read(zPattern, 0, &zPattern);
      }
      if( c2==0 || (seen ^ invert)==0 ){
        return 0;
      }
    }else if( esc==c && !prevEscape ){
      prevEscape = 1;
    }else{
      c2 = sqlite3Utf8Read(zString, 0, &zString);
      if( noCase ){
        GlogUpperToLower(c);
        GlogUpperToLower(c2);
      }
      if( c!=c2 ){
        return 0;
      }
      prevEscape = 0;
    }
  }
  return *zString==0;
}

/*
** Count the number of times that the LIKE operator (or GLOB which is
** just a variation of LIKE) gets called.  This is used for testing
** only.
*/
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_like_count = 0;
#endif

/*
** Implementation of the like() SQL function.  This function implements
** the build-in LIKE operator.  The first argument to the function is the
** pattern and the second argument is the string.  So, the SQL statements:
**
**       A LIKE B
**
** is implemented as like(B,A).
**
** This same function (with a different compareInfo structure) computes
** the GLOB operator.
*/
static void likeFunc(
  sqlite3_context *context, 
  int argc, 
  sqlite3_value **argv
){
  const unsigned char *zA, *zB;
  int escape = 0;
#if 0
  sqlite3 *db = sqlite3_context_db_handle(context);*/
#endif
  zB = sqlite3_value_text(argv[0]);
  zA = sqlite3_value_text(argv[1]);

  /* Limit the length of the LIKE or GLOB pattern to avoid problems
  ** of deep recursion and N*N behavior in patternCompare().
  */
#if 0
  if( sqlite3_value_bytes(argv[0]) >
        db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] ){
#endif
#if 1
  if( sqlite3_value_bytes(argv[0])>SQLITE_MAX_LIKE_PATTERN_LENGTH ){
#endif
    sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
    return;
  }

  assert( zB==sqlite3_value_text(argv[0]) );  /* Encoding did not change */

  if( argc==3 ){
    /* The escape character string must consist of a single UTF-8 character.
    ** Otherwise, return an error.
    */
    const unsigned char *zEsc = sqlite3_value_text(argv[2]);
    if( zEsc==0 ) return;
    if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){
      sqlite3_result_error(context, 
          "ESCAPE expression must be a single character", -1);
      return;
    }
    escape = sqlite3Utf8Read(zEsc, 0, &zEsc);
  }
  if( zA && zB ){
    struct compareInfo *pInfo = sqlite3_user_data(context);
#ifdef SQLITE_TEST
    sqlite3_like_count++;
#endif
    
    sqlite3_result_int(context, patternCompare(zB, zA, pInfo, escape));
  }
}

/*
** Allocate nByte bytes of space using sqlite3_malloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed.
*/
static void *contextMalloc(sqlite3_context *context, i64 nByte){
  char *z;
#if 0
  if( nByte>sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH] ){
    sqlite3_result_error_toobig(context);
    z = 0;
  }else{
#endif
    z = sqlite3_malloc((int)nByte);
    if( !z && nByte>0 ){
      sqlite3_result_error_nomem(context);
    }
#if 0
  }
#endif
  return z;
}

/*
** <sqlite3_unicode>
** Reallocate nByte bytes of space using sqlite3_realloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed.
**
** SQlite has not supplied us with a reallocate function so we build our own.
*/
SQLITE_PRIVATE void *contextRealloc(sqlite3_context *context, void* pPrior, i64 nByte){
  char *z = sqlite3_realloc(pPrior, (int)nByte);
  if( !z && nByte>0 ){
    sqlite3_result_error_nomem(context);
  }
  return z;
}

#if (defined(SQLITE3_UNICODE_FOLD) || defined(SQLITE3_UNICODE_LOWER) || defined(SQLITE3_UNICODE_UPPER) || defined(SQLITE3_UNICODE_TITLE))
/*
** <sqlite3_unicode>
** Implementation of the FOLD(), UPPER(), LOWER(), TITLE() SQL functions.
** This function case folds each character in the supplied string to its
** single character equivalent.
**
** The conversion to be made depends on the contents of (sqlite3_context *)context
** where a pointer to a specific case conversion function is stored.
*/
SQLITE_PRIVATE void caseFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  u16 *z1;
  const u16 *z2;
  int i, n;
  if( argc<1 || SQLITE_NULL==sqlite3_value_type(argv[0]) ) return;
  z2 = (u16*)sqlite3_value_text16(argv[0]);
  n = sqlite3_value_bytes16(argv[0]);
  /* Verify that the call to _bytes() does not invalidate the _text() pointer */
  assert( z2==(u16*)sqlite3_value_text16(argv[0]) );
  if( z2 ){
    z1 = contextMalloc(context, n+2);
    if( z1 ){
      typedef u16 (*PFN_CASEFUNC)(u16);
      memcpy(z1, z2, n+2);
      for(i=0; z1[i]; i++){
        z1[i] = ((PFN_CASEFUNC)sqlite3_user_data(context))(z1[i]);
      }
      sqlite3_result_text16(context, z1, -1, sqlite3_free);
    }
  }
}
#endif

#ifdef SQLITE3_UNICODE_UNACC
/*
** <sqlite3_unicode>
** Implementation of the UNACCENT() SQL function.
** This function decomposes each character in the supplied string
** to its components and strips any accents present in the string.
**
** This function may result to a longer output string compared
** to the original input string. Memory has been properly reallocated
** to accomodate for the extra memory length required.
*/
SQLITE_PRIVATE void unaccFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {
    u16 *z1;
    const u16 *z2;
    unsigned short *p;
    int i, o, n, l, k;
    if (argc < 1 || SQLITE_NULL == sqlite3_value_type(argv[0]))
        return;
    z2 = (u16 *)sqlite3_value_text16(argv[0]);
    n  = sqlite3_value_bytes16(argv[0]);
    /* Verify that the call to _bytes() does not invalidate the _text() pointer */
    assert(z2 == (u16 *)sqlite3_value_text16(argv[0]));
    if (z2) {
        z1 = contextMalloc(context, n + 2);
        if (z1) {
            memcpy(z1, z2, n + 2);
            for (i = 0, o = 0; z2[i]; i++, o++) {
                simpleUnicodeUnacc(z2[i], &p, &l);
                if (l > 0) {
                    if (l > 1) {
                        n += (l - 1) * sizeof(u16);
                        z1 = contextRealloc(context, z1, n + 2);
                    }
                    for (k = 0; k < l; k++)
                        z1[o + k] = p[k];
                    o += --k;
                } else
                    z1[o] = z2[i];
            }
            z1[o] = 0;
            sqlite3_result_text16(context, z1, -1, sqlite3_free);
        }
    }
}
#endif


#if defined(SQLITE3_UNICODE_COLLATE) && defined(SQLITE3_UNICODE_FOLD)

#ifndef max
# define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

/*
** Some systems have stricmp().  Others have strcasecmp().  Because
** there is no consistency, we will define our own.
*/
/*
** <sqlite3_unicode>
** The buit-in function has been extended to accomodate UTF-8 and UTF-16
** unicode strings containing characters over the 0x80 character limit as
** per the ASCII encoding imposed by SQlite.
**
** The functions below will use the sqlite3_unicode_fold() when 
** SQLITE3_UNICODE_FOLD is defined and additonally sqlite_unicode_unacc()
** when SQLITE3_UNICODE_UNACC_AUTOMATIC is defined to normilize
** UTF-8 and UTF-16 encoded strings and then compaire them for equality.
*/
SQLITE_PRIVATE int sqlite3StrNICmp(const unsigned char *zLeft, const unsigned char *zRight, int N){
  const unsigned char *a = zLeft;
  const unsigned char *b = zRight;
  signed int ua = 0, ub = 0;
  int Z = 0;
  
  do { 
    ua = sqlite3Utf8Read(a, 0, &a);  ub = sqlite3Utf8Read(b, 0, &b);
    GlogUpperToLower(ua);       GlogUpperToLower(ub);
    Z = (int)max(a - zLeft, b - zRight);
  } while(N > Z && *a!=0 && ua==ub);
  return N<0 ? 0 : ua - ub;
}
SQLITE_PRIVATE int sqlite3StrNICmp16(const void *zLeft, const void *zRight, int N){
  const unsigned short *a = zLeft;
  const unsigned short *b = zRight;
  signed int ua = 0, ub = 0;

  do {
    ua = *a;               ub = *b;
    GlogUpperToLower(ua);  GlogUpperToLower(ub);
    a++; b++;
  } while(--N > 0 && *a!=0 && ua==ub);
  return N<0 ? 0 : ua - ub;
}

/*
** Another built-in collating sequence: NOCASE. 
**
** This collating sequence is intended to be used for "case independant
** comparison". SQLite's knowledge of upper and lower case equivalents
** extends only to the 26 characters used in the English language.
**
** At the moment there is only a UTF-8 implementation.
*/
/*
** <sqlite3_unicode>
** The built-in collating sequence: NOCASE is extended to accomodate the
** unicode case folding mapping tables to normalize characters to their
** fold equivalents and test them for equality.
**
** Both UTF-8 and UTF-16 implementations are supported.
** 
** (void *)encoding takes the following values
**   * SQLITE_UTF8  for UTF-8  encoded string comparison
**   * SQLITE_UFT16 for UTF-16 encoded string comparison
*/
SQLITE_EXPORT int sqlite3_unicode_collate(
  void *encoding,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  int r = 0;
  
  if ((void*)SQLITE_UTF8 == encoding)
    r = sqlite3StrNICmp(
        (const unsigned char *)pKey1, (const unsigned char *)pKey2, (nKey1<nKey2)?nKey1:nKey2);
  else if  ((void*)SQLITE_UTF16 == encoding)
    r = sqlite3StrNICmp16(
        (const void *)pKey1, (const void *)pKey2, (nKey1<nKey2)?nKey1:nKey2);
  
  if( 0==r ){
    r = nKey1-nKey2;
  }
  return r;
}
#endif

/*
** <sqlite3_unicode>
** Implementation of the UNICODE_VERSION(*) function.  The result is the version
** of the unicode library that is running.
*/
SQLITE_PRIVATE void versionFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  (void)argc;
  (void)argv;
  sqlite3_result_text(context, SQLITE3_UNICODE_VERSION_STRING, -1, SQLITE_STATIC);
}

/*
** <sqlite3_unicode>
** Register the UNICODE extension functions with database db.
*/
SQLITE_EXPORT int sqlite3_unicode_init(sqlite3 *db){
  struct FuncScalar {
    const char *zName;                        /* Function name */
    int nArg;                                 /* Number of arguments */
    int enc;                                  /* Optimal text encoding */
    void *pContext;                           /* sqlite3_user_data() context */
    void (*xFunc)(sqlite3_context*,int,sqlite3_value**);
  } scalars[] = {
  {"unicode_version", 0,  SQLITE_ANY,                            0, versionFunc},

#ifdef SQLITE3_UNICODE_FOLD
  {"like",            2,  SQLITE_ANY,         (void*)&likeInfoNorm, likeFunc   },
  {"like",            3,  SQLITE_ANY,         (void*)&likeInfoNorm, likeFunc   },

  {"fold",            1,  SQLITE_ANY,  (void*)simpleUnicodeFold, caseFunc   },
#endif  
#ifdef SQLITE3_UNICODE_LOWER
  {"lower",           1,  SQLITE_ANY, (void*)simpleUnicodeLower, caseFunc   },
#endif
#ifdef SQLITE3_UNICODE_UPPER
  {"upper",           1,  SQLITE_ANY, (void*)simpleUnicodeUpper, caseFunc   },
#endif
#ifdef SQLITE3_UNICODE_TITLE
  {"title",           1,  SQLITE_ANY, (void*)simpleUnicodeTitle, caseFunc   },
#endif
#ifdef SQLITE3_UNICODE_UNACC
      {"unaccent", 1, SQLITE_ANY, 0, unaccFunc},
#endif
  };

  int rc = SQLITE_OK;
  int i;

  for(i=0; rc==SQLITE_OK && i<(int)(sizeof(scalars)/sizeof(struct FuncScalar)); i++){
    struct FuncScalar *p = &scalars[i];
    rc = sqlite3_create_function(
         db, p->zName, p->nArg, p->enc, p->pContext, p->xFunc, 0, 0
    );
  }

#if defined(SQLITE3_UNICODE_COLLATE) && defined(SQLITE3_UNICODE_FOLD)
  /* Also override the default NOCASE UTF-8 case-insensitive collation sequence. */
  rc = sqlite3_create_collation(db, "NOCASE",  SQLITE_UTF8,  (void*)SQLITE_UTF8, sqlite3_unicode_collate);
  rc = sqlite3_create_collation(db, "NOCASE", SQLITE_UTF16, (void*)SQLITE_UTF16, sqlite3_unicode_collate);
#endif

  return rc;
}

/*
** <sqlite3_unicode>
** The following function is the default entry point of an SQlite extension built as a
** dynamically linked library. On calling sqlite3_load_extension() sqlite3 will call
** this function to initialise unicode functionality.
*/
#ifndef SQLITE_CORE
SQLITE_EXPORT int sqlite3_extension_init(
  sqlite3 *db, 
  char **pzErrMsg,
  const sqlite3_api_routines *pApi
){
  (void)pzErrMsg;
  SQLITE_EXTENSION_INIT2(pApi)
  return sqlite3_unicode_init(db);
}
#endif

/*
** <sqlite3_unicode>
** The following function needs to be called at application startup to load the extension.
*/
SQLITE_EXPORT int sqlite3_unicode_load()
{
#ifndef SQLITE_CORE
  return sqlite3_auto_extension((void*)sqlite3_extension_init);
#else
  return sqlite3_auto_extension((void*)sqlite3_unicode_init);
#endif
}

/*
** <sqlite3_unicode>
** The following function needs to be called before application exit to unload the extension.
*/
SQLITE_EXPORT void sqlite3_unicode_free()
{
  sqlite3_reset_auto_extension();
}
#endif

/*
** <sqlite3_unicode>
** Hack for Microsoft Windows where sqlite3_unicode is statically linked to
** an sqlite3 dynamically linked library. DllMain will be automatically be called
** by Microsoft Windows when the library is loaded into the application to automatically
** load extension and when unloaded to automatically unload the extension. 
*/
#if ((defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)) && (!defined(SQLITE_CORE)))
int __stdcall DllMain(void *hinstDLL, unsigned long fdwReason, void *lpReserved)
{
  if (fdwReason == 1 /*DLL_PROCESS_ATTACH*/)
    sqlite3_unicode_load();
  else if (fdwReason == 0 /*DLL_PROCESS_DETACH*/)
    sqlite3_unicode_free();
  return 1;
}
#endif

//#endif  //!defined(SQLITE_CORE) || defined(SQLITE_ENABLE_UNICODE)
